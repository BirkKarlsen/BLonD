

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>llrf Package &mdash; BLonD 1.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="BLonD 1.1 documentation" href="../index.html"/>
        <link rel="next" title="monitors Package" href="monitors.html"/>
        <link rel="prev" title="input_parameters Package" href="input_parameters.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> BLonD
          

          
          </a>

          
            
            
              <div class="version">
                1.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="equations_of_motion.html">Equations of Motion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#definitions">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#energy-kick">Energy kick</a></li>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#arrival-time-drift">Arrival time drift</a></li>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#the-synchronous-particle">The synchronous particle</a></li>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#small-amplitude-oscillations">Small-amplitude oscillations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="equations_of_motion.html#tracking-utilities">Tracking utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#hamiltonian">Hamiltonian</a></li>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#separatrix">Separatrix</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="beam.html">beam Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.beam"><code class="xref py py-mod docutils literal notranslate"><span class="pre">beam</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.coasting_beam"><code class="xref py py-mod docutils literal notranslate"><span class="pre">coasting_beam</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.distributions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distributions</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.distributions_multibunch"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distributions_multibunch</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.profile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.sparse_slices"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sparse_slices</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="impedances.html">impedances Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="impedances.html#module-blond.impedances.impedance"><code class="xref py py-mod docutils literal notranslate"><span class="pre">impedance</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="impedances.html#module-blond.impedances.impedance_sources"><code class="xref py py-mod docutils literal notranslate"><span class="pre">impedance_sources</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="impedances.html#module-blond.impedances.induced_voltage_analytical"><code class="xref py py-mod docutils literal notranslate"><span class="pre">induced_voltage_analytical</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="impedances.html#module-blond.impedances.music"><code class="xref py py-mod docutils literal notranslate"><span class="pre">music</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="input_parameters.html">input_parameters Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="input_parameters.html#module-blond.input_parameters.rf_parameters"><code class="xref py py-mod docutils literal notranslate"><span class="pre">rf_parameters</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="input_parameters.html#module-blond.input_parameters.ring"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ring</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="input_parameters.html#module-blond.input_parameters.ring_options"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ring_options</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="input_parameters.html#module-blond.input_parameters.rf_parameters_options"><code class="xref py py-mod docutils literal notranslate"><span class="pre">rf_parameters_options</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">llrf Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-blond.llrf.notch_filter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">notch_filter</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#llrf-beam-feedback-module">llrf.beam_feedback Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#machine-dependent-beam-phase-loop">Machine-dependent Beam Phase Loop</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-blond.llrf.cavity_feedback"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cavity_feedback</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-blond.llrf.impulse_response"><code class="xref py py-mod docutils literal notranslate"><span class="pre">impulse_response</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-blond.llrf.rf_modulation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">rf_modulation</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#llrf-rf-noise-module">llrf.rf_noise Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rf-phase-noise-generation">RF phase noise generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lhc-type-phase-noise-generation">LHC-type phase noise generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bunch-length-based-feedback-on-noise-amplitude">Bunch-length based feedback on noise amplitude</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-blond.llrf.signal_processing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal_processing</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="monitors.html">monitors Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="monitors.html#module-blond.monitors.monitors"><code class="xref py py-mod docutils literal notranslate"><span class="pre">monitors</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="plots.html">plots Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot"><code class="xref py py-mod docutils literal notranslate"><span class="pre">plot</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot_beams"><code class="xref py py-mod docutils literal notranslate"><span class="pre">plot_beams</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot_impedance"><code class="xref py py-mod docutils literal notranslate"><span class="pre">plot_impedance</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot_llrf"><code class="xref py py-mod docutils literal notranslate"><span class="pre">plot_llrf</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot_parameters"><code class="xref py py-mod docutils literal notranslate"><span class="pre">plot_parameters</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot_slices"><code class="xref py py-mod docutils literal notranslate"><span class="pre">plot_slices</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="synchrotron_radiation.html">synchrotron_radiation Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="synchrotron_radiation.html#module-blond.synchrotron_radiation.synchrotron_radiation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">synchrotron_radiation</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="toolbox.html">toolbox Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.action"><code class="xref py py-mod docutils literal notranslate"><span class="pre">action</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.convolution"><code class="xref py py-mod docutils literal notranslate"><span class="pre">convolution</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.diffusion"><code class="xref py py-mod docutils literal notranslate"><span class="pre">diffusion</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.next_regular"><code class="xref py py-mod docutils literal notranslate"><span class="pre">next_regular</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.parameter_scaling"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parameter_scaling</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.tomoscope"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tomoscope</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trackers.html">trackers Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trackers.html#module-blond.trackers.tracker"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracker</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trackers.html#module-blond.trackers.utilities"><code class="xref py py-mod docutils literal notranslate"><span class="pre">utilities</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="compile.html">compile Module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="compile.html#id1"><code class="xref py py-mod docutils literal notranslate"><span class="pre">compile</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">utils Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="utils.html#module-blond.utils.bmath"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bmath</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="utils.html#module-blond.utils.bphysics_wrap"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bphysics_wrap</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="utils.html#module-blond.utils.butils_wrap"><code class="xref py py-mod docutils literal notranslate"><span class="pre">butils_wrap</span></code> Module</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>
    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">BLonD</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>llrf Package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/modules/llrf.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="llrf-package">
<h1>llrf Package<a class="headerlink" href="#llrf-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-blond.llrf.notch_filter">
<span id="notch-filter-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">notch_filter</span></code> Module<a class="headerlink" href="#module-blond.llrf.notch_filter" title="Permalink to this headline">¶</a></h2>
<p><strong>Method to apply a notch filter to a specified impedance source</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p><strong>Danilo Quartullo</strong></p>
</dd>
</dl>
<dl class="function">
<dt id="blond.llrf.notch_filter.impedance_notches">
<code class="descclassname">blond.llrf.notch_filter.</code><code class="descname">impedance_notches</code><span class="sig-paren">(</span><em>f_rev</em>, <em>frequencies</em>, <em>imp_source</em>, <em>list_harmonics</em>, <em>list_width_depth</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.impedance_notches" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="llrf-beam-feedback-module">
<h2>llrf.beam_feedback Module<a class="headerlink" href="#llrf-beam-feedback-module" title="Permalink to this headline">¶</a></h2>
<p><strong>Various beam phase loops (PL) with optional synchronisation (SL), frequency
(FL), or radial loops (RL) for the CERN machines</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p><strong>Helga Timko</strong></p>
</dd>
</dl>
<div class="section" id="machine-dependent-beam-phase-loop">
<h3>Machine-dependent Beam Phase Loop<a class="headerlink" href="#machine-dependent-beam-phase-loop" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop">
<em class="property">class </em><code class="descclassname">llrf.phase_loop.</code><code class="descname">PhaseLoop</code><span class="sig-paren">(</span><em>object).__init__(GeneralParameters</em>, <em>RFSectionParameters</em>, <em>Slices</em>, <em>gain</em>, <em>gain2 = 0</em>, <em>machine = 'LHC'</em>, <em>period = None</em>, <em>window_coefficient = 0</em>, <em>coefficients = None</em>, <em>PhaseNoise = None</em>, <em>LHCNoiseFB = None</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>One-turn PL for different machines with different hardware. The beam phase is
calculated as the convolution of the beam profile with the RF wave of the
main harmonic system (corresponding to a band-pass filter). The PL acts
directly on the RF frequency and phase of all harmonics.</p>
<p>Some machine-dependent features:</p>
<ul class="simple">
<li><p>PSB: use <code class="docutils literal notranslate"><span class="pre">sampling_frequency</span></code> for a PL that is active only at certain
turns.</p></li>
<li><p>SPS: use <code class="docutils literal notranslate"><span class="pre">window</span> <span class="pre">coefficient</span></code> to sample beam phase over a suitable
amount of bunches (<code class="docutils literal notranslate"><span class="pre">window_coefficient</span> <span class="pre">=</span> <span class="pre">0</span></code> results in single-bunch
acquisition as in the LHC)</p></li>
<li><p>LHC_F: PL with optional FL (use <code class="docutils literal notranslate"><span class="pre">gain2</span></code> to activate)</p></li>
<li><p>LHC: PL with optional SL (use <code class="docutils literal notranslate"><span class="pre">gain2</span></code> to activate; note that gain is
frequency dependent)</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>GeneralParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.general_parameters.GeneralParameters</span></code></p></li>
<li><p><strong>RFSectionParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.rf_parameters.RFSectionParameters</span></code></p></li>
<li><p><strong>Slices</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">beams.slices.Slices</span></code></p></li>
<li><p><strong>gain</strong> (<em>double</em>) – phase loop gain [1/ns], typically <span class="math notranslate nohighlight">\(\sim 1/(10 T_0)\)</span></p></li>
<li><p><strong>gain2</strong> (<em>double</em>) – FL gain [turns] or SL gain [1/ns], depending on machine;
typically ~10 times weaker than PL</p></li>
<li><p><strong>machine</strong> (<em>str</em>) – machine name, determines PL choice</p></li>
<li><p><strong>period</strong> (<em>double</em>) – optional for PSB: period of PL being active</p></li>
<li><p><strong>window_coefficient</strong> (<em>double</em>) – window coefficient for band-pass filter
determining beam phase; use 0 for single-bunch acquisition</p></li>
<li><p><strong>coefficients</strong> (<em>array</em>) – optional for PSB: PL transfer function
coefficients</p></li>
<li><p><strong>PhaseNoise</strong> – optional: phase-noise type class for noise injection
through the PL,
<code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.rf_noise.PhaseNoise</span></code> or
<code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.rf_noise.LHCFlatSpectrum</span></code></p></li>
<li><p><strong>LHCNoiseFB</strong> – optional: bunch-length feedback class for phase noise
<code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.rf_noise.LHCNoiseFB</span></code></p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.track">
<code class="descname">track</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.track" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the PL correction on main RF frequency depending on machine.
Updates the RF phase and frequency of the next turn for all RF systems.</p>
<p>Let <span class="math notranslate nohighlight">\(\Delta \omega_{\mathsf{TOT}}\)</span> be the total frequency correction
(calculation depends on the machine, see below). The RF frequency of a
given RF system <span class="math notranslate nohighlight">\(i\)</span> is then shifted by</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{\mathsf{rf},i} = \frac{h_i}{h_0} \Delta
\omega_{\mathsf{TOT}} ,\]</div>
<p>with a corresponding RF phase shift of</p>
<div class="math notranslate nohighlight">
\[\Delta \varphi_{\mathsf{rf},i} = 2 \pi h_i
\frac{\omega_{\mathsf{rf},i}}{\Omega_{\mathsf{rf},i}} ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\Omega_{\mathsf{rf},i} = h_i \omega_0\)</span> is the design
frequency and <span class="math notranslate nohighlight">\(\omega_{\mathsf{rf},i}\)</span> the actual RF frequency
applied.</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.precalculate_time">
<code class="descname">precalculate_time</code><span class="sig-paren">(</span><em>GeneralParameters</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.precalculate_time" title="Permalink to this definition">¶</a></dt>
<dd><p>For PSB, where the PL acts only with a given periodicity, pre-calculate on
which turns to act.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>GeneralParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.general_parameters.GeneralParameters</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.beam_phase">
<code class="descname">beam_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.beam_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Beam phase measured at the main RF frequency and phase. The beam is
convolved with the window function of the band-pass filter of the machine.
The coefficients of sine and cosine components determine the beam phase,
projected to the range -Pi/2 to 3/2 Pi.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>that this beam phase is already determined w.r.t. the
instantaneous RF phase.</p>
</div>
<p>The band-pass filter modelled assumes a window function of the form</p>
<div class="math notranslate nohighlight">
\[W(t) = e^{-\alpha t}
\cos(\omega_{\mathsf{rf}} t - \varphi_{\mathsf{rf}}) ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is the <code class="docutils literal notranslate"><span class="pre">window_coefficient</span></code> that determines how
many bunches are taken into account.</p>
<p>The convolution of <span class="math notranslate nohighlight">\(W(t)\)</span> with the bunch profile <span class="math notranslate nohighlight">\(\lambda(t)\)</span>
results in two components,</p>
<div class="math notranslate nohighlight">
\[f(t) = \int_{\lambda_{\mathsf{min}}}^{\lambda_{\mathsf{max}}}
{e^{-\alpha (t-\tau)} \cos(\omega_{\mathsf{rf}} (t-\tau) -
\varphi_{\mathsf{rf}}) \lambda(\tau) d\tau}
= e^{-\alpha t} \cos(\omega_{\mathsf{rf}} t)
\int_{\lambda_{\mathsf{min}}}^{\lambda_{\mathsf{max}}}
{e^{\alpha \tau} \cos(\omega_{\mathsf{rf}} \tau +
\varphi_{\mathsf{rf}}) \lambda(\tau) d\tau}
+ e^{-\alpha t} \sin(\omega_{\mathsf{rf}} t)
\int_{\lambda_{\mathsf{min}}}^{\lambda_{\mathsf{max}}}
{e^{\alpha \tau} \sin(\omega_{\mathsf{rf}} \tau +
\varphi_{\mathsf{rf}}) \lambda(\tau) d\tau} .\]</div>
<p>The beam phase is determined from the coefficients of the sine and cosine
components, i.e.</p>
<div class="math notranslate nohighlight">
\[\varphi_b \equiv \arctan \left(
\frac{\int_{\lambda_{\mathsf{min}}}^{\lambda_{\mathsf{max}}}
{e^{\alpha \tau} \sin(\omega_{\mathsf{rf}} \tau +
\varphi_{\mathsf{rf}}) \lambda(\tau) d\tau}}
{\int_{\lambda_{\mathsf{min}}}^{\lambda_{\mathsf{max}}}
{e^{\alpha \tau} \cos(\omega_{\mathsf{rf}} \tau +
\varphi_{\mathsf{rf}}) \lambda(\tau) d\tau}} \right) .\]</div>
<p>This projects the beam phase to the interval
<span class="math notranslate nohighlight">\(\left( -\frac{\pi}{2} , \frac{\pi}{2}\right)\)</span>, however, the RF
phase is defined on the interval
<span class="math notranslate nohighlight">\(\left( -\frac{\pi}{2} , \frac{3 \pi}{2}\right)\)</span>. In order to get a
correct measurement of the beam phase, we thus add <span class="math notranslate nohighlight">\(\pi\)</span> if the
cosine coefficient is negative (meaning normally the beam energy is above
transition).</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.phase_difference">
<code class="descname">phase_difference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.phase_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase difference between beam and RF phase of the main RF system.
Optional: add RF phase noise through dphi directly.</p>
<p>As the actual RF phase is taken into account already in the beam phase
calculation, only the synchronous phase needs to be substracted and thus
the phase difference seen by the PL becomes</p>
<div class="math notranslate nohighlight">
\[\Delta \varphi_{\mathsf{PL}} = \varphi_b - \varphi_s .\]</div>
<p>If phase noise is injected through the PL, it is added directly as an
offset to this measurement, optionally with the feedback scaling factor
<span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[\Delta \varphi_{\mathsf{PL}} = \varphi_b - \varphi_s
+ (x) \phi_N .\]</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">LHC_F():</code></dt>
<dd><p>Calculates the RF frequency correction <span class="math notranslate nohighlight">\(\Delta \omega_{\mathsf{PL}}\)</span>
from the phase difference between beam and RF
<span class="math notranslate nohighlight">\(\Delta \varphi_{\mathsf{PL}}\)</span> for the LHC. The transfer function is</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{\mathsf{PL}} = - g_{\mathsf{PL}}
\Delta\varphi_{\mathsf{PL}} ,\]</div>
<p>Using ‘gain2’, the frequency loop can be activated in addition to remove
long-term frequency drifts:</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{\mathsf{FL}} = - g_{\mathsf{FL}}
(\omega_{\mathsf{rf}} - h \omega_{0}) .\]</div>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.LHC">
<code class="descname">LHC</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.LHC" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the RF frequency correction <span class="math notranslate nohighlight">\(\Delta \omega_{\mathsf{PL}}\)</span>
from the phase difference between beam and RF
<span class="math notranslate nohighlight">\(\Delta \varphi_{\mathsf{PL}}\)</span> for the LHC. The transfer function is</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{\mathsf{PL}} = - g_{\mathsf{PL}}
\Delta \varphi_{\mathsf{PL}} ,\]</div>
<p>Using ‘gain2’, a synchro loop can be activated in addition to remove
long-term frequency and phase drifts:</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{\mathsf{SL}} = - g_{\mathsf{SL}}
(y + a \, \Delta \varphi_{\mathsf{rf}}) ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta \varphi_{\mathsf{rf}}\)</span> is the accumulated RF phase
deviation from the design value and <span class="math notranslate nohighlight">\(y\)</span> is is obtained through the
recursion (<span class="math notranslate nohighlight">\(y_0 = 0\)</span>)</p>
<div class="math notranslate nohighlight">
\[y_{n+1} = (1 - \tau) y_n + (1 - a) \tau
\Delta \varphi_{\mathsf{rf}} .\]</div>
<p>The variables <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span> are being defined through the
(single-harmonic, central) synchrotron frequency <span class="math notranslate nohighlight">\(f_s\)</span> and the
corresponding synchrotron tune <span class="math notranslate nohighlight">\(Q_s\)</span> as</p>
<div class="math notranslate nohighlight">
\[a (f_s) \equiv 5.25 - \frac{f_s}{\pi 40~\text{Hz}} ,\]</div>
<div class="math notranslate nohighlight">
\[\tau(f_s) \equiv 2 \pi Q_s \sqrt{ \frac{a}{1 +
\frac{g_{\mathsf{PL}}}{g_{\mathsf{SL}}} \sqrt{\frac{1 + 1/a}{1 + a}} }} .\]</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">PSB():</code></dt>
<dd><p>Phase loop:</p>
<p>The transfer function of the system is</p>
<div class="math notranslate nohighlight">
\[H(z) = g \frac{b_{0}+b_{1} z^{-1}}{1 +a_{1} z^{-1}}\]</div>
<p>where g is the gain and <span class="math notranslate nohighlight">\(b_{0} = 0.99901903\)</span>, <span class="math notranslate nohighlight">\(b_{1} = -0.99901003\)</span>,
<span class="math notranslate nohighlight">\(a_{1} = -0.99803799\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\(\Delta \phi_{PL}\)</span> and <span class="math notranslate nohighlight">\(\Delta \omega_{PL}\)</span> be the
phase difference and the phase loop correction on the frequency
respectively; since these two quantities are the input and output of our
system, then from the transfer function we
have in time domain (see <a class="reference external" href="https://en.wikipedia.org/wiki/Z-transform">https://en.wikipedia.org/wiki/Z-transform</a>):</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{PL}^{n+1} = - a_{1} \Delta \omega_{PL}^{n} +
g(b_{0} \Delta \phi_{PL}^{n+1} + b_{1} \Delta \phi_{PL}^{n})\]</div>
<p>In fact the phase and radial loops act every 10 <span class="math notranslate nohighlight">\(\mu s\)</span> and as a
consequence <span class="math notranslate nohighlight">\(\Delta \phi_{PL}\)</span> is an average on all the values
between two trigger times.</p>
<p>Radial loop:</p>
<p>We estimate
the difference of the radii of the actual trajectory and the desired trajectory
using one of the four known differential relations with <span class="math notranslate nohighlight">\(\Delta B = 0\)</span>:</p>
<div class="math notranslate nohighlight">
\[\frac{\Delta R}{R} = \frac{\Delta \omega_{RF}}{\omega_{RF}}
\frac{\gamma^2}{\gamma_{T}^2-\gamma^2}\]</div>
<p>In reality the error <span class="math notranslate nohighlight">\(\Delta R\)</span> is filtered with a PI (Proportional-
Integrator) corrector. This means that</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{RL}^{n+1} = K_{P} \left(\frac{\Delta R}{R}\right)^{n}
+ K_{I} \int_0^n \! \frac{\Delta R}{R} (t) \, \mathrm{d}t.\]</div>
<p>Writing the same equation for <span class="math notranslate nohighlight">\(\Delta \omega_{RL}^{n}\)</span> and
subtracting side by side we have</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{RL}^{n+1} = \Delta \omega_{RL}^{n} +
K_{P} \left[ \left(\frac{\Delta R}{R}\right)^{n} -
\left(\frac{\Delta R}{R}\right)^{n-1} \right] + K_{I}^{'}
\left(\frac{\Delta R}{R}\right)^{n}\]</div>
<p>here <span class="math notranslate nohighlight">\(K_{I}^{'} = K_{I} 10 \mu s\)</span> and we approximated the integral
with a simple product.</p>
<p>The total correction is then</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{RF}^{n+1} = \Delta \omega_{PL}^{n+1} + \Delta \omega_{RL}^{n+1}\]</div>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-blond.llrf.cavity_feedback">
<span id="cavity-feedback-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">cavity_feedback</span></code> Module<a class="headerlink" href="#module-blond.llrf.cavity_feedback" title="Permalink to this headline">¶</a></h2>
<p><strong>Various cavity loops for the CERN machines</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p><strong>Helga Timko</strong></p>
</dd>
</dl>
<dl class="class">
<dt id="blond.llrf.cavity_feedback.CavityFeedbackCommissioning">
<em class="property">class </em><code class="descclassname">blond.llrf.cavity_feedback.</code><code class="descname">CavityFeedbackCommissioning</code><span class="sig-paren">(</span><em>debug=False</em>, <em>open_loop=False</em>, <em>open_FB=False</em>, <em>open_drive=False</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.CavityFeedbackCommissioning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="class">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop">
<em class="property">class </em><code class="descclassname">blond.llrf.cavity_feedback.</code><code class="descname">LHCCavityLoop</code><span class="sig-paren">(</span><em>RFStation</em>, <em>Profile</em>, <em>f_c=400789000.0</em>, <em>G_gen=1</em>, <em>I_gen_offset=0</em>, <em>n_cav=8</em>, <em>n_pretrack=200</em>, <em>Q_L=20000</em>, <em>R_over_Q=45</em>, <em>tau_loop=6.5e-07</em>, <em>RFFB=&lt;blond.llrf.cavity_feedback.LHCRFFeedback object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Cavity loop to regulate the RF voltage in the LHC ACS cavities.
The loop contains a generator, a switch-and-protect device, an RF FB and a
OTFB. The arrays of the LLRF system cover one turn with exactly one tenth
of the harmonic (i.e.the typical sampling time is about 25 ns).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RFStation</strong> (<em>class</em>) – An RFStation type class</p></li>
<li><p><strong>Profile</strong> (<em>class</em>) – Beam profile object</p></li>
<li><p><strong>RFFB</strong> (<em>class</em>) – LHCRFFeedback type class containing RF FB gains and delays</p></li>
<li><p><strong>f_c</strong> (<em>float</em>) – Central cavity frequency [Hz]</p></li>
<li><p><strong>G_gen</strong> (<em>float</em>) – Overall driver chain gain [1]</p></li>
<li><p><strong>I_gen_offset</strong> (<em>float</em>) – Generator current offset [A]</p></li>
<li><p><strong>n_cav</strong> (<em>int</em>) – Number of cavities per beam (default is 8)</p></li>
<li><p><strong>n_pretrack</strong> (<em>int</em>) – Number of turns to pre-track without beam (default is 1)</p></li>
<li><p><strong>Q_L</strong> (<em>float</em>) – Cavity loaded quality factor (default is 20000)</p></li>
<li><p><strong>R_over_Q</strong> (<em>float</em>) – Cavity R/Q [Ohm] (default is 45 Ohms)</p></li>
<li><p><strong>tau_loop</strong> (<em>float</em>) – Total loop delay [s]</p></li>
<li><p><strong>Ts</strong> (<em>float</em>) – Sampling time of the LLRF loops [s] (default is 25 ns)</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.n_coarse">
<code class="descname">n_coarse</code><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.n_coarse" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of bins for the coarse grid (equals harmonic number)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.t_centers">
<code class="descname">t_centers</code><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.t_centers" title="Permalink to this definition">¶</a></dt>
<dd><p>Time shift w.r.t. clock, corresponding to voltage arrays</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.omega_c">
<code class="descname">omega_c</code><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.omega_c" title="Permalink to this definition">¶</a></dt>
<dd><p>Central cavity revolution frequency [1/s]</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.V_coarse_tot">
<code class="descname">V_coarse_tot</code><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.V_coarse_tot" title="Permalink to this definition">¶</a></dt>
<dd><p>Cavity voltage [V] at present turn in (I,Q) coordinates which is used
for tracking the LLRF</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.logger">
<code class="descname">logger</code><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Logger of the present class</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>logger</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.cavity_response">
<code class="descname">cavity_response</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.cavity_response" title="Permalink to this definition">¶</a></dt>
<dd><p>ACS cavity reponse model</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.generator_current">
<code class="descname">generator_current</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.generator_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator response</p>
<p>Attributes
I_TEST : complex array</p>
<blockquote>
<div><p>Test point for open loop measurements (when injecting a generator
offset)</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.generator_power">
<code class="descname">generator_power</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.generator_power" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculation of generator power from generator current</p>
</dd></dl>

<dl class="staticmethod">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.half_detuning">
<em class="property">static </em><code class="descname">half_detuning</code><span class="sig-paren">(</span><em>imag_peak_beam_current</em>, <em>R_over_Q</em>, <em>rf_frequency</em>, <em>voltage</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.half_detuning" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimum detuning for half-detuning scheme</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>peak_beam_current</strong> (<em>float</em>) – Peak RF beam current</p></li>
<li><p><strong>R_over_Q</strong> (<em>float</em>) – Cavity R/Q</p></li>
<li><p><strong>rf_frequency</strong> (<em>float</em>) – RF frequency</p></li>
<li><p><strong>voltage</strong> (<em>float</em>) – RF voltage amplitude in the cavity</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Optimum detuning (revolution) frequency in the half-detuning scheme</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.half_detuning_power">
<em class="property">static </em><code class="descname">half_detuning_power</code><span class="sig-paren">(</span><em>peak_beam_current</em>, <em>voltage</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.half_detuning_power" title="Permalink to this definition">¶</a></dt>
<dd><p>RF power consumption half-detuning scheme with optimum detuning</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>peak_beam_current</strong> (<em>float</em>) – Peak RF beam current</p></li>
<li><p><strong>voltage</strong> (<em>float</em>) – Cavity voltage</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Optimum detuning (revolution) frequency in the half-detuning scheme</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.one_turn_feedback">
<code class="descname">one_turn_feedback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.one_turn_feedback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.optimum_Q_L">
<em class="property">static </em><code class="descname">optimum_Q_L</code><span class="sig-paren">(</span><em>detuning</em>, <em>rf_frequency</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.optimum_Q_L" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimum loaded Q when no real part of RF beam current is present</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>detuning</strong> (<em>float</em>) – Detuning frequency</p></li>
<li><p><strong>rf_frequency</strong> (<em>float</em>) – RF frequency</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Optimum loaded Q</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.optimum_Q_L_beam">
<em class="property">static </em><code class="descname">optimum_Q_L_beam</code><span class="sig-paren">(</span><em>R_over_Q</em>, <em>real_peak_beam_current</em>, <em>voltage</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.optimum_Q_L_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimum loaded Q when a real part of RF beam current is present</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>peak_beam_current</strong> (<em>float</em>) – Peak RF beam current</p></li>
<li><p><strong>R_over_Q</strong> (<em>float</em>) – Cavity R/Q</p></li>
<li><p><strong>voltage</strong> (<em>float</em>) – Cavity voltage</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Optimum loaded Q</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.rf_beam_current">
<code class="descname">rf_beam_current</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.rf_beam_current" title="Permalink to this definition">¶</a></dt>
<dd><p>RF beam current calculation from beam profile</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.rf_feedback">
<code class="descname">rf_feedback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.rf_feedback" title="Permalink to this definition">¶</a></dt>
<dd><p>Analog and digital RF feedback response</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.set_point">
<code class="descname">set_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.set_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Voltage set point</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.swap">
<code class="descname">swap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Model of the Switch and Protect module: clamping of the output
power above a given input power.</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.track">
<code class="descname">track</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.track" title="Permalink to this definition">¶</a></dt>
<dd><p>Tracking with beam</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.track_no_beam">
<code class="descname">track_no_beam</code><span class="sig-paren">(</span><em>n_turns</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.track_no_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-tracking for n_turns turns, without beam. No excitation; set
point from design RF voltage.</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.track_no_beam_excitation">
<code class="descname">track_no_beam_excitation</code><span class="sig-paren">(</span><em>n_turns</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.track_no_beam_excitation" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-tracking for n_turns turns, without beam. With excitation; set
point from white noise. V_EXC_IN and V_EXC_OUT can be used to measure
the transfer function of the system.</p>
<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.V_EXC_IN">
<code class="descname">V_EXC_IN</code><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.V_EXC_IN" title="Permalink to this definition">¶</a></dt>
<dd><p>Noise being played in set point; n_coarse*n_turns elements</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.V_EXC_OUT">
<code class="descname">V_EXC_OUT</code><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.V_EXC_OUT" title="Permalink to this definition">¶</a></dt>
<dd><p>System reaction to noise (accumulated from V_ANT); n_coarse*n_turns
elements</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.track_one_turn">
<code class="descname">track_one_turn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.track_one_turn" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-turn tracking, index by index.</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.track_simple">
<code class="descname">track_simple</code><span class="sig-paren">(</span><em>I_rf_pk</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.track_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplified model with proportional gain and step beam current of
1000 samples lengthBM7_ACS_with_beam.py</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>I_rf_peak</strong> (<em>float</em>) – Peak RF current</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.update_arrays">
<code class="descname">update_arrays</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.update_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Moves the array indices by one turn (n_coarse points) from the
present turn to prepare the next turn. All arrays except for V_SET.</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.update_set_point">
<code class="descname">update_set_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.update_set_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the set point for the next turn based on the design RF
voltage.</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.update_set_point_excitation">
<code class="descname">update_set_point_excitation</code><span class="sig-paren">(</span><em>excitation</em>, <em>turn</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.update_set_point_excitation" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the set point for the next turn based on the excitation to
be injected.</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCCavityLoop.update_variables">
<code class="descname">update_variables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCCavityLoop.update_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Update counter and frequency-dependent variables in a given turn</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="blond.llrf.cavity_feedback.LHCRFFeedback">
<em class="property">class </em><code class="descclassname">blond.llrf.cavity_feedback.</code><code class="descname">LHCRFFeedback</code><span class="sig-paren">(</span><em>alpha=0.9375</em>, <em>d_phi_ad=0</em>, <em>G_a=1e-05</em>, <em>G_d=10</em>, <em>G_o=10</em>, <em>tau_a=0.00017</em>, <em>tau_d=0.0004</em>, <em>tau_o=0.00011</em>, <em>open_drive=False</em>, <em>open_loop=False</em>, <em>open_otfb=False</em>, <em>open_rffb=False</em>, <em>excitation=False</em>, <em>seed1=1234</em>, <em>seed2=7564</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCRFFeedback" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>RF Feedback settings for LHC ACS cavity loop.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha</strong> (<em>float</em>) – One-turn feedback memory parameter; default is 15/16</p></li>
<li><p><strong>d_phi_ad</strong> (<em>float</em>) – Phase misalignment of digital FB w.r.t. analog FB [deg]</p></li>
<li><p><strong>G_a</strong> (<em>float</em>) – Analog FB gain [1]</p></li>
<li><p><strong>G_d</strong> (<em>float</em>) – Digital FB gain, w.r.t. analog gain [1]</p></li>
<li><p><strong>G_o</strong> (<em>float</em>) – One-turn feedback gain</p></li>
<li><p><strong>tau_a</strong> (<em>float</em>) – Analog FB delay time [s]</p></li>
<li><p><strong>tau_d</strong> (<em>float</em>) – Digital FB delay time [s]</p></li>
<li><p><strong>tau_o</strong> (<em>float</em>) – AC-coupling delay time of one-turn feedback [s]</p></li>
<li><p><strong>open_drive</strong> (<em>bool</em>) – Open (True) or closed (False) cavity loop at drive; default is False</p></li>
<li><p><strong>open_loop</strong> (<em>bool</em>) – Open (True) or closed (False) cavity loop at RFFB; default is False</p></li>
<li><p><strong>open_otfb</strong> (<em>bool</em>) – Open (true) or closed (False) one-turn feedback; default is False</p></li>
<li><p><strong>open_rffb</strong> (<em>bool</em>) – Open (True) or closed (False) RFFB; default is False</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.LHCRFFeedback.d_phi_ad">
<code class="descname">d_phi_ad</code><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCRFFeedback.d_phi_ad" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase misalignment of digital FB w.r.t. analog FB [rad]</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.LHCRFFeedback.open_drive">
<code class="descname">open_drive</code><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCRFFeedback.open_drive" title="Permalink to this definition">¶</a></dt>
<dd><p>Open (0) or closed (1) cavity loop at drive; default is 1</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int(bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.LHCRFFeedback.open_loop">
<code class="descname">open_loop</code><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCRFFeedback.open_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Open (0) or closed (1) cavity loop at RFFB; default is 1</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int(bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.LHCRFFeedback.open_rffb">
<code class="descname">open_rffb</code><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCRFFeedback.open_rffb" title="Permalink to this definition">¶</a></dt>
<dd><p>Open (0) or closed (1) RFFB; default is 1</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int(bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.LHCRFFeedback.generate_white_noise">
<code class="descname">generate_white_noise</code><span class="sig-paren">(</span><em>n_points</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.LHCRFFeedback.generate_white_noise" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback">
<em class="property">class </em><code class="descclassname">blond.llrf.cavity_feedback.</code><code class="descname">SPSCavityFeedback</code><span class="sig-paren">(</span><em>RFStation</em>, <em>Beam</em>, <em>Profile</em>, <em>G_llrf=10</em>, <em>G_tx=0.5</em>, <em>a_comb=0.9375</em>, <em>turns=1000</em>, <em>Commissioning=&lt;blond.llrf.cavity_feedback.CavityFeedbackCommissioning object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class determining the turn-by-turn total RF voltage and phase correction
originating from the individual cavity feedbacks. Assumes two 4-section and
two 5-section travelling wave cavities and a voltage partition proportional
to the number of sections.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RFStation</strong> (<em>class</em>) – An RFStation type class</p></li>
<li><p><strong>Beam</strong> (<em>class</em>) – A Beam type class</p></li>
<li><p><strong>Profile</strong> (<em>class</em>) – A Profile type class</p></li>
<li><p><strong>G_llrf</strong> (<em>float</em><em> or </em><em>list</em>) – LLRF Gain [1]; if passed as a float, both 4- and 5-section cavities
have the same G_llrf; if passed as a list, the first and second
elements correspond to the G_llrf of the 4- and 5-section cavity
feedback; default is 10</p></li>
<li><p><strong>G_tx</strong> (<em>float</em><em> or </em><em>list</em>) – Transmitter gain [1] of the cavity feedback; convention same as G_llrf;
default is 0.5</p></li>
<li><p><strong>open_loop</strong> (<em>int</em><em>(</em><em>bool</em><em>)</em>) – Open (0) or closed (1) feedback loop; default is 1</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.OTFB_4">
<code class="descname">OTFB_4</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.OTFB_4" title="Permalink to this definition">¶</a></dt>
<dd><p>An SPSOneTurnFeedback type class</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>class</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.OTFB_5">
<code class="descname">OTFB_5</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.OTFB_5" title="Permalink to this definition">¶</a></dt>
<dd><p>An SPSOneTurnFeedback type class</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>class</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.V_sum">
<code class="descname">V_sum</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.V_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector sum of RF voltage from all the cavities</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.V_corr">
<code class="descname">V_corr</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.V_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>RF voltage correction array to be applied in the tracker</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.phi_corr">
<code class="descname">phi_corr</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.phi_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>RF phase correction array to be applied in the tracker</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.logger">
<code class="descname">logger</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Logger of the present class</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>logger</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.track">
<code class="descname">track</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.track" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.track_init">
<code class="descname">track_init</code><span class="sig-paren">(</span><em>debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.track_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Tracking of the SPSCavityFeedback without beam.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback">
<em class="property">class </em><code class="descclassname">blond.llrf.cavity_feedback.</code><code class="descname">SPSOneTurnFeedback</code><span class="sig-paren">(</span><em>RFStation</em>, <em>Beam</em>, <em>Profile_</em>, <em>n_sections</em>, <em>n_cavities=2</em>, <em>V_part=0.4444444444444444</em>, <em>G_llrf=10</em>, <em>G_tx=0.5</em>, <em>a_comb=0.9375</em>, <em>Commissioning=&lt;blond.llrf.cavity_feedback.CavityFeedbackCommissioning object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Voltage feedback around a travelling wave cavity with given amount of
sections. The quantities of the LLRF system cover one turn with a coarse
resolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RFStation</strong> (<em>class</em>) – An RFStation type class</p></li>
<li><p><strong>Beam</strong> (<em>class</em>) – A Beam type class</p></li>
<li><p><strong>Profile</strong> (<em>class</em>) – Beam profile object</p></li>
<li><p><strong>n_sections</strong> (<em>int</em>) – Number of sections in the cavities</p></li>
<li><p><strong>n_cavities</strong> (<em>int</em>) – Number of cavities of the same type</p></li>
<li><p><strong>V_part</strong> (<em>float</em>) – Voltage partition for the given n_cavities; in range (0,1)</p></li>
<li><p><strong>G_tx</strong> (<em>float</em>) – Transmitter gain [A/V]; default is <span class="math notranslate nohighlight">\((50 \Omega)^{-1}\)</span></p></li>
<li><p><strong>open_loop</strong> (<em>int</em><em>(</em><em>bool</em><em>)</em>) – Open (0) or closed (1) feedback loop; default is 1</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.TWC">
<code class="descname">TWC</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.TWC" title="Permalink to this definition">¶</a></dt>
<dd><p>A TravellingWaveCavity type class</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>class</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.counter">
<code class="descname">counter</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.counter" title="Permalink to this definition">¶</a></dt>
<dd><p>Counter of the current time step</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.omega_c">
<code class="descname">omega_c</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.omega_c" title="Permalink to this definition">¶</a></dt>
<dd><p>Carrier revolution frequency [1/s] at the current time step</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.omega_r">
<code class="descname">omega_r</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.omega_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Resonant revolution frequency [1/s] of the travelling wave cavities</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>const float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.n_coarse">
<code class="descname">n_coarse</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.n_coarse" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of bins for the coarse grid (equals harmonic number)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_gen">
<code class="descname">V_gen</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator voltage [V] of the present turn in (I,Q) coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_gen_prev">
<code class="descname">V_gen_prev</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_gen_prev" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator voltage [V] of the previous turn in (I,Q) coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_fine_ind_beam">
<code class="descname">V_fine_ind_beam</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_fine_ind_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Beam-induced voltage [V] in (I,Q) coordinates on the fine grid
used for tracking the beam</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_ind_beam">
<code class="descname">V_coarse_ind_beam</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_ind_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Beam-induced voltage [V] in (I,Q) coordinates on the coarse grid used
tracking the LLRF</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_ind_gen">
<code class="descname">V_coarse_ind_gen</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_ind_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator-induced voltage [V] in (I,Q) coordinates on the coarse grid
used tracking the LLRF</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_tot">
<code class="descname">V_coarse_tot</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_tot" title="Permalink to this definition">¶</a></dt>
<dd><p>Cavity voltage [V] at present turn in (I,Q) coordinates which is used
for tracking the LLRF</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_fine_tot">
<code class="descname">V_fine_tot</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_fine_tot" title="Permalink to this definition">¶</a></dt>
<dd><p>Cavity voltage [V] at present turn in (I,Q) coordinates which is used
for tracking the beam</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.a_comb">
<code class="descname">a_comb</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.a_comb" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursion constant of the comb filter; <span class="math notranslate nohighlight">\(a_{\mathsf{comb}}=15/16\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.n_mov_av">
<code class="descname">n_mov_av</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.n_mov_av" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of points for moving average modelling cavity response;
<span class="math notranslate nohighlight">\(n_{\mathsf{mov.av.}} = \frac{f_r}{f_{\mathsf{bw,cav}}}\)</span>, where
<span class="math notranslate nohighlight">\(f_r\)</span> is the cavity resonant frequency of TWC_4 and TWC_5</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>const int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.logger">
<code class="descname">logger</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Logger of the present class</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>logger</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.beam_induced_voltage">
<code class="descname">beam_induced_voltage</code><span class="sig-paren">(</span><em>lpf=False</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.beam_induced_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the beam-induced voltage</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lpf</strong> (<em>bool</em>) – Apply low-pass filter for beam current calculation;
default is False</p>
</dd>
</dl>
<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.I_beam">
<code class="descname">I_beam</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.I_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>RF component of the beam charge [C] at the present time step</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">V_coarse_ind_beam</code></dt>
<dd><p>Induced voltage [V] from beam-cavity interaction on the coarse grid</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">V_fine_ind_beam</code></dt>
<dd><p>Induced voltage [V] from beam-cavity interaction on the fine grid</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.beam_induced_voltage_semi_analytic">
<code class="descname">beam_induced_voltage_semi_analytic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.beam_induced_voltage_semi_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the beam-induced voltage in (I,Q) at the present carrier
frequency <span class="math notranslate nohighlight">\(\omega_c\)</span> using the semi-analytic method. It requires
that pre_compute_semi_analytic_factor() was called previously.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Beam-induced voltage in (I,Q) at <span class="math notranslate nohighlight">\(\omega_c\)</span></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>complex array [V]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.call_conv">
<code class="descname">call_conv</code><span class="sig-paren">(</span><em>signal</em>, <em>kernel</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.call_conv" title="Permalink to this definition">¶</a></dt>
<dd><p>Routine to call optimised C++ convolution</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.generator_induced_voltage">
<code class="descname">generator_induced_voltage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.generator_induced_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the generator-induced voltage. The transmitter model is
a simple linear gain [C/V] converting voltage to charge.</p>
<div class="math notranslate nohighlight">
\[I = G_{\mathsf{tx}}\,\frac{V}{R_{\mathsf{gen}}} \, ,\]</div>
<p>where <span class="math notranslate nohighlight">\(R_{\mathsf{gen}}\)</span> is the generator resistance,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">llrf.impulse_response.TravellingWaveCavity.R_gen</span></code></p>
<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.I_gen">
<code class="descname">I_gen</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.I_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>RF component of the generator charge [C] at the present time step</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">V_coarse_ind_gen</code></dt>
<dd><p>Induced voltage [V] from generator-cavity interaction</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.induced_voltage">
<code class="descname">induced_voltage</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.induced_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>Generation of beam- or generator-induced voltage from the beam or
generator current, at a given carrier frequency and turn. The induced
voltage <span class="math notranslate nohighlight">\(V(t)\)</span> is calculated from the impulse response matrix
<span class="math notranslate nohighlight">\(h(t)\)</span> as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left( \begin{matrix} V_I(t) \\
V_Q(t) \end{matrix} \right)
= \left( \begin{matrix} h_s(t) &amp; - h_c(t) \\
h_c(t) &amp; h_s(t) \end{matrix} \right)
* \left( \begin{matrix} I_I(t) \\
I_Q(t) \end{matrix} \right) \, ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(*\)</span> denotes convolution,
<span class="math notranslate nohighlight">\(h(t)*x(t) = \int d\tau h(\tau)x(t-\tau)\)</span>. If the carrier
frequency is close to the cavity resonant frequency, <span class="math notranslate nohighlight">\(h_c = 0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">See also</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.impulse_response.TravellingWaveCavity</span></code></p>
</dd>
</dl>
<p>The impulse response is made to be the same length as the beam profile.</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.llrf_model">
<code class="descname">llrf_model</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.llrf_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Models the LLRF part of the OTFB.</p>
<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_set">
<code class="descname">V_set</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Voltage set point [V] in (I,Q); <span class="math notranslate nohighlight">\(V_{\mathsf{set}}\)</span>, amplitude
proportional to voltage partition</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.dV_gen">
<code class="descname">dV_gen</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.dV_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator voltage [V] in (I,Q);
<span class="math notranslate nohighlight">\(dV_{\mathsf{gen}} = V_{\mathsf{set}} - V_{\mathsf{tot}}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.matr_conv">
<code class="descname">matr_conv</code><span class="sig-paren">(</span><em>I</em>, <em>h</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.matr_conv" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolution of beam current with impulse response; uses a complete
matrix with off-diagonal elements.</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.pre_compute_semi_analytic_factor">
<code class="descname">pre_compute_semi_analytic_factor</code><span class="sig-paren">(</span><em>time</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.pre_compute_semi_analytic_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-computes factor for semi-analytic method, which is used to
compute the beam-induced voltage on the coarse grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time</strong> (<em>float array</em><em> [</em><em>s</em><em>]</em>) – Time array at which to compute the beam-induced voltage</p>
</dd>
</dl>
<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.profile_coarse">
<code class="descname">profile_coarse</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.profile_coarse" title="Permalink to this definition">¶</a></dt>
<dd><p>Beam profile with 20 bins per RF-bucket</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>class</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.semi_analytic_factor">
<code class="descname">semi_analytic_factor</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.semi_analytic_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Factor that is used to compute the beam-induced voltage</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array [<span class="math notranslate nohighlight">\(\Omega\,s\)</span>]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.track">
<code class="descname">track</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.track" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn-by-turn tracking method.</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.track_no_beam">
<code class="descname">track_no_beam</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.track_no_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial tracking method, before injecting beam.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-blond.llrf.impulse_response">
<span id="impulse-response-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">impulse_response</span></code> Module<a class="headerlink" href="#module-blond.llrf.impulse_response" title="Permalink to this headline">¶</a></h2>
<p><strong>Filters and methods for control loops</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p><strong>Helga Timko</strong></p>
</dd>
</dl>
<dl class="class">
<dt id="blond.llrf.impulse_response.SPS4Section200MHzTWC">
<em class="property">class </em><code class="descclassname">blond.llrf.impulse_response.</code><code class="descname">SPS4Section200MHzTWC</code><a class="headerlink" href="#blond.llrf.impulse_response.SPS4Section200MHzTWC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#blond.llrf.impulse_response.TravellingWaveCavity" title="blond.llrf.impulse_response.TravellingWaveCavity"><code class="xref py py-class docutils literal notranslate"><span class="pre">blond.llrf.impulse_response.TravellingWaveCavity</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="blond.llrf.impulse_response.SPS5Section200MHzTWC">
<em class="property">class </em><code class="descclassname">blond.llrf.impulse_response.</code><code class="descname">SPS5Section200MHzTWC</code><a class="headerlink" href="#blond.llrf.impulse_response.SPS5Section200MHzTWC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#blond.llrf.impulse_response.TravellingWaveCavity" title="blond.llrf.impulse_response.TravellingWaveCavity"><code class="xref py py-class docutils literal notranslate"><span class="pre">blond.llrf.impulse_response.TravellingWaveCavity</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity">
<em class="property">class </em><code class="descclassname">blond.llrf.impulse_response.</code><code class="descname">TravellingWaveCavity</code><span class="sig-paren">(</span><em>l_cell</em>, <em>N_cells</em>, <em>rho</em>, <em>v_g</em>, <em>omega_r</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Impulse responses of a travelling wave cavity. The induced voltage
<span class="math notranslate nohighlight">\(V(t)\)</span> from the impulse response <span class="math notranslate nohighlight">\(h(t)\)</span> and the I,Q (cavity or
generator) current <span class="math notranslate nohighlight">\(I(t)\)</span> can be written in matrix form,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left( \begin{matrix} V_I(t) \\
V_Q(t) \end{matrix} \right)
= \left( \begin{matrix} h_s(t) &amp; - h_c(t) \\
h_c(t) &amp; h_s(t) \end{matrix} \right)
* \left( \begin{matrix} I_I(t) \\
I_Q(t) \end{matrix} \right) \, ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(*\)</span> denotes convolution,
<span class="math notranslate nohighlight">\(h(t)*x(t) = \int d\tau h(\tau)x(t-\tau)\)</span>.</p>
<p>For the <strong>cavity-to-beam induced voltage</strong>, we define</p>
<div class="math notranslate nohighlight">
\[R_b \equiv \frac{\rho l^2}{8} \,\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho\)</span> is the series impedance, <span class="math notranslate nohighlight">\(l\)</span> the accelerating
length, <span class="math notranslate nohighlight">\(\tau\)</span> the filling time. The cavity-to-beam wake is</p>
<div class="math notranslate nohighlight">
\[W_b(t) = \frac{4 R_b}{\tau} \mathsf{tri}\left(\frac{t}{\tau}\right)
 \cos(\omega_r t)\]</div>
<p>and the impulse response components are</p>
<div class="math notranslate nohighlight">
\[\begin{split}h_{s,b}(t) &amp;= \frac{2 R_b}{\tau} \mathsf{tri}\left(\frac{t}{\tau}\right)
 \cos((\omega_c - \omega_r)t) \, , \\
h_{c,b}(t) &amp;= \frac{2 R_b}{\tau} \mathsf{tri}\left(\frac{t}{\tau}\right)
\sin((\omega_c - \omega_r)t) \, ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathsf{tri}(x)\)</span> is the triangular function, <span class="math notranslate nohighlight">\(\omega_r\)</span>
is the central revolution frequency of the cavity, and <span class="math notranslate nohighlight">\(\omega_c\)</span> is
the carrier revolution frequency of the I,Q demodulated current signal. On
the carrier frequency, <span class="math notranslate nohighlight">\(\omega_c = \omega_r\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}h_{s,b}(t) &amp;= \frac{2 R_b}{\tau} \mathsf{tri}\left(\frac{t}{\tau}\right) \\
h_{c,b}(t) &amp;= 0 \, .\end{split}\]</div>
<p>For the <strong>cavity-to-generator induced voltage</strong>, we define</p>
<div class="math notranslate nohighlight">
\[R_g \equiv l \sqrt{\frac{\rho Z_0}{2}} \,\]</div>
<p>where <span class="math notranslate nohighlight">\(Z_0\)</span> is the shunt impedance when measuring the generator
current; assumed to be 50 <span class="math notranslate nohighlight">\(\Omega\)</span>. The cavity-to-generator wake is</p>
<div class="math notranslate nohighlight">
\[W_g(t) = \frac{2 R_g}{\tau} \mathsf{rect}\left(\frac{t}{\tau}\right)
\cos(\omega_r t)\]</div>
<p>and the impulse response components are</p>
<div class="math notranslate nohighlight">
\[\begin{split}h_{s,g}(t) &amp;= \frac{R_g}{\tau} \mathsf{rect}\left(\frac{t}{\tau}\right)
\cos((\omega_c - \omega_r)t) \, , \\
h_{c,g}(t) &amp;= \frac{R_g}{\tau} \mathsf{rect}\left(\frac{t}{\tau}\right)
\sin((\omega_c - \omega_r)t) \, ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathsf{rect}(x)\)</span> is the rectangular function. On the carrier
frequency, <span class="math notranslate nohighlight">\(\omega_c = \omega_r\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}h_{s,g}(t) &amp;= \frac{R_g}{\tau} \mathsf{rect}\left(\frac{t}{\tau}\right) \\
h_{c,g}(t) &amp;= 0 \, .\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>l_cell</strong> (<em>float</em>) – Cavity cell length [m]</p></li>
<li><p><strong>N_cells</strong> (<em>int</em>) – Number of accelerating (interacting) cells in a cavity</p></li>
<li><p><strong>rho</strong> (<em>float</em>) – Series impedance [Ohms/m^2] of the cavity</p></li>
<li><p><strong>v_g</strong> (<em>float</em>) – Group velocity [c] in units of the speed of light</p></li>
<li><p><strong>omega_r</strong> (<em>flaot</em>) – Central (resonance) revolution frequency [1/s] of the cavity</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.Z_0">
<code class="descname">Z_0</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.Z_0" title="Permalink to this definition">¶</a></dt>
<dd><p>Shunt impedance of generator current measurement; assumed to be 50 Ohms</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.R_beam">
<code class="descname">R_beam</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.R_beam" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(R_b\)</span> [Omega] as defined above</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.R_gen">
<code class="descname">R_gen</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.R_gen" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(R_g\)</span> [Omega] as defined above</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.l_cav">
<code class="descname">l_cav</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.l_cav" title="Permalink to this definition">¶</a></dt>
<dd><p>Length [m] of the interaction region</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.tau">
<code class="descname">tau</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.tau" title="Permalink to this definition">¶</a></dt>
<dd><p>Cavity filling time [s]</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.compute_wakes">
<code class="descname">compute_wakes</code><span class="sig-paren">(</span><em>time</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.compute_wakes" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the wake fields towards the beam and generator on the
central cavity frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_beam</strong> (<em>float</em>) – Time array of the beam to act on</p></li>
<li><p><strong>time_gen</strong> (<em>float</em>) – Time array of the generator to act on</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.W_beam">
<code class="descname">W_beam</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.W_beam" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(W_b(t)\)</span> [Omega/s] as defined above</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.W_gen">
<code class="descname">W_gen</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.W_gen" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(W_g(t)\)</span> [Omega/s] as defined above</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.impulse_response_beam">
<code class="descname">impulse_response_beam</code><span class="sig-paren">(</span><em>omega_c</em>, <em>time_fine</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.impulse_response_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Impulse response from the cavity towards the beam. For a signal
that is I,Q demodulated at a given carrier
frequency <span class="math notranslate nohighlight">\(\omega_c\)</span>. The formulae assume that the carrier
frequency is be close to the central frequency
<span class="math notranslate nohighlight">\(\omega_c/\omega_r \ll 1\)</span> and that the signal is low-pass
filtered (i.e.high-frequency components can be neglected).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>omega_c</strong> (<em>float</em>) – Carrier revolution frequency [1/s]</p></li>
<li><p><strong>time_fine</strong> (<em>float</em>) – Time array of the beam profile to act on</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.d_omega">
<code class="descname">d_omega</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.d_omega" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(\omega_c - \omega_r\)</span> [1/s]</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.t_beam">
<code class="descname">t_beam</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.t_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>time array for beam wake and impulse response; starts from zero</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.hs_beam">
<code class="descname">hs_beam</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.hs_beam" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(h_{s,b}(t)\)</span> [Omega/s] as defined above</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.hc_beam">
<code class="descname">hc_beam</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.hc_beam" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(h_{c,b}(t)\)</span> [Omega/s] as defined above</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.impulse_response_gen">
<code class="descname">impulse_response_gen</code><span class="sig-paren">(</span><em>omega_c</em>, <em>time_coarse</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.impulse_response_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Impulse response from the cavity towards the
generator. For a signal that is I,Q demodulated at a given carrier
frequency <span class="math notranslate nohighlight">\(\omega_c\)</span>. The formulae assume that the carrier
frequency is be close to the central frequency
<span class="math notranslate nohighlight">\(\omega_c/\omega_r \ll 1\)</span> and that the signal is low-pass
filtered (i.e.high-frequency components can be neglected).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>omega_c</strong> (<em>float</em>) – Carrier revolution frequency [1/s]</p></li>
<li><p><strong>time_coarse</strong> (<em>float</em>) – Time array of the LLRF to act on</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt>
<code class="descname">d_omega</code></dt>
<dd><p><span class="math notranslate nohighlight">\(\omega_c - \omega_r\)</span> [1/s]</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.t_gen">
<code class="descname">t_gen</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.t_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>time array for generator wake and impulse response; starts from
<span class="math notranslate nohighlight">\(- \tau/2\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.hs_gen">
<code class="descname">hs_gen</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.hs_gen" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(h_{s,g}(t)\)</span> [Omega/s] as defined above</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.hc_gen">
<code class="descname">hc_gen</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.hc_gen" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(h_{c,g}(t)\)</span> [Omega/s] as defined above</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="function">
<dt id="blond.llrf.impulse_response.rectangle">
<code class="descclassname">blond.llrf.impulse_response.</code><code class="descname">rectangle</code><span class="sig-paren">(</span><em>t</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Rectangular function of time</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathsf{rect} \left( \frac{t}{\tau} \right) =
\begin{cases}
    1 \, , \, t \in (-\tau/2, \tau/2) \\
    0.5 \, , \, t = \pm \tau/2 \\
    0 \, , \, \textsf{otherwise}
\end{cases}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>float array</em>) – Time array</p></li>
<li><p><strong>tau</strong> (<em>float</em>) – Time window of rectangular function</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Rectangular function for given time array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="blond.llrf.impulse_response.triangle">
<code class="descclassname">blond.llrf.impulse_response.</code><code class="descname">triangle</code><span class="sig-paren">(</span><em>t</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.triangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Triangular function of time</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathsf{tri} \left( \frac{t}{\tau} \right) =
\begin{cases}
    1 - \frac{t}{\tau}\, , \, t \in (0, \tau) \\
    0.5 \, , \, t = 0 \\
    0 \, , \, \textsf{otherwise}
\end{cases}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>float array</em>) – Time array</p></li>
<li><p><strong>tau</strong> (<em>float</em>) – Time window of rectangular function</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Triangular function for given time array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-blond.llrf.rf_modulation">
<span id="rf-modulation-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">rf_modulation</span></code> Module<a class="headerlink" href="#module-blond.llrf.rf_modulation" title="Permalink to this headline">¶</a></h2>
<p><strong>Methods to generate RF phase modulation from given frequency, amplitude
and offset functions</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p><strong>Simon Albright</strong></p>
</dd>
</dl>
<dl class="function">
<dt id="blond.llrf.rf_modulation.ModulateHarmonic">
<code class="descclassname">blond.llrf.rf_modulation.</code><code class="descname">ModulateHarmonic</code><span class="sig-paren">(</span><em>Ring</em>, <em>RFStation</em>, <em>modulationList</em>, <em>harmonic</em>, <em>includeFreq=True</em>, <em>preshift=0</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.ModulateHarmonic" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to apply modulation(s) to RFStation
modulationList is a list of modulation objects applied
sequentially to RFStation.</p>
<p>harmonicList specifies which harmonic of RFStation
will be modulated</p>
<p>includeFreq flag determines if effect of modulation on
RF frequency should be included.  False will treat
modulation as pure phase shift, True will include the
small frequency shift needed to adjust the phase.</p>
</dd></dl>

<dl class="class">
<dt id="blond.llrf.rf_modulation.PhaseModulation">
<em class="property">class </em><code class="descclassname">blond.llrf.rf_modulation.</code><code class="descname">PhaseModulation</code><span class="sig-paren">(</span><em>frequency</em>, <em>amplitude</em>, <em>offset</em>, <em>time</em>, <em>freqMultiplier=1</em>, <em>interpType='cubic'</em>, <em>smoothing=1000</em>, <em>ontime=0</em>, <em>offtime=0</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.PhaseModulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

</div>
<div class="section" id="llrf-rf-noise-module">
<h2>llrf.rf_noise Module<a class="headerlink" href="#llrf-rf-noise-module" title="Permalink to this headline">¶</a></h2>
<p><strong>Methods to generate RF phase noise from noise spectrum and feedback noise
amplitude as a function of bunch length</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p><strong>Helga Timko</strong></p>
</dd>
</dl>
<div class="section" id="rf-phase-noise-generation">
<h3>RF phase noise generation<a class="headerlink" href="#rf-phase-noise-generation" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise">
<em class="property">class </em><code class="descclassname">llrf.rf_noise.</code><code class="descname">PhaseNoise</code><span class="sig-paren">(</span><em>object).__init__(frequency_array</em>, <em>real_part_of_spectrum</em>, <em>seed1=None</em>, <em>seed2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the spectrum of RF phase noise and the actual phase noise randomly
generated from it. Generation done via mixing with white noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frequency_array</strong> (<em>numpy.array</em>) – input frequency range</p></li>
<li><p><strong>real_part_of_spectrum</strong> (<em>numpy.array</em>) – input spectrum, real part only,
same length as <code class="docutils literal notranslate"><span class="pre">frequency_array</span></code></p></li>
<li><p><strong>seed1</strong> (<em>int</em>) – seed for random number generator</p></li>
<li><p><strong>seed2</strong> (<em>int</em>) – seed for random number generator</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The spectrum has to be input as double-sided spectrum, in units
of [<span class="math notranslate nohighlight">\(\text{rad}^2/\text{Hz}\)</span>].</p>
</div>
<p>Both hermitian to real and complex to complex FFTs are available. Use seeds
to fix a certain random number sequence; with <code class="docutils literal notranslate"><span class="pre">seed=None</span></code> a random sequence
will be initialized.</p>
<dl class="method">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise.spectrum_to_phase_noise">
<code class="descname">spectrum_to_phase_noise</code><span class="sig-paren">(</span><em>transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise.spectrum_to_phase_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms a noise spectrum to phase noise data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>transform</strong> (<em>choice</em>) – FFT transform kind</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>time and phase noise arrays</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">transform=None</span></code> or <code class="docutils literal notranslate"><span class="pre">'r'</span></code> to transform hermitian
spectrum to real phase. In this case, input only the positive part of
the double-sided spectrum. Use <code class="docutils literal notranslate"><span class="pre">transform='c'</span></code> to transform complex
spectrum to complex phase. In this case, input first the zero and
positive frequency components, then the decreasingly negative frequency
components of the double-sided spectrum. Returns only the real part of
the phase noise. E.g. the following two ways of usage are equivalent:</p>
<a class="reference internal image-reference" href="../_images/RF_noise.png"><img alt="../_images/RF_noise.png" class="align-center" src="../_images/RF_noise.png" style="width: 1000px; height: 250px;" /></a>
</div>
<p><strong>The transformation in steps</strong></p>
<p><strong>Step 1:</strong> Set the resolution in time domain. To transform a hermitian
spectrum to real phase noise,</p>
<div class="math notranslate nohighlight">
\[n_t = 2 (n_f - 1) \text{\,\,and\,\,} \Delta t = 1/(2 f_{\text{max}}) ,\]</div>
<p>and to transform a complex spectrum to complex phase noise,</p>
<div class="math notranslate nohighlight">
\[n_t = n_f \text{\,\,and\,\,} \Delta t = 1/f_{\text{max}} ,\]</div>
<p>where <code class="docutils literal notranslate"><span class="pre">fmax</span></code> is the maximum frequency in the input in both cases.</p>
<p><strong>Step 2:</strong> Generate white (carrier) noise in time domain</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}w_k(t) = \cos(2 \pi r_k^{(1)}) \sqrt{-2 \ln(r_k^{(2)})} \text{\,\,\,case `r'},\\w_k(t) = \exp(2 \pi i r_k^{(1)}) \sqrt{-2 \ln(r_k^{(2)})} \text{\,\,\,case `c'},\end{aligned}\end{align} \]</div>
<p><strong>Step 3:</strong> Transform the generated white noise to frequency domain</p>
<div class="math notranslate nohighlight">
\[W_l(f) = \sum_{k=1}^N w_k(t) e^{-2 \pi i \frac{k l}{N}} .\]</div>
<p><strong>Step 4:</strong> In frequency domain, colour the white noise with the desired
noise probability density (unit: radians). The noise probability density
derived from the double-sided spectrum is</p>
<div class="math notranslate nohighlight">
\[s_l(f) = \sqrt{A S_l^{\text{DB}} f_{\text{max}}} ,\]</div>
<p>where <span class="math notranslate nohighlight">\(A=2\)</span> for <code class="docutils literal notranslate"><span class="pre">transform</span> <span class="pre">=</span> <span class="pre">'r'</span></code> and <span class="math notranslate nohighlight">\(A=1\)</span> for
<code class="docutils literal notranslate"><span class="pre">transform</span> <span class="pre">=</span> <span class="pre">'c'</span></code>. The coloured noise is obtained by multiplication in
frequency domain</p>
<div class="math notranslate nohighlight">
\[\Phi_l(f) = s_l(f) W_l(f) .\]</div>
<p><strong>Step 5:</strong> Transform back the coloured spectrum to time domain to obtain
the final phase shift array (we use only the real part).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="lhc-type-phase-noise-generation">
<h3>LHC-type phase noise generation<a class="headerlink" href="#lhc-type-phase-noise-generation" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum">
<em class="property">class </em><code class="descclassname">llrf.rf_noise.</code><code class="descname">LHCFlatSpectrum</code><span class="sig-paren">(</span><em>object).__init__(GeneralParameters</em>, <em>RFSectionParameters</em>, <em>time_points</em>, <em>corr_time = 10000</em>, <em>fmin = 0.8571</em>, <em>fmax = 1.1</em>, <em>initial_amplitude = 1.e-6</em>, <em>seed1 = 1234</em>, <em>seed2 = 7564</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates LHC-type phase noise from a band-limited spectrum. Input frequency
band using <code class="docutils literal notranslate"><span class="pre">fmin</span></code> and <code class="docutils literal notranslate"><span class="pre">fmax</span></code> w.r.t. the synchrotron frequency. Input
double-sided spectrum amplitude [<span class="math notranslate nohighlight">\(\text{rad}^2/\text{Hz}\)</span>] using
<code class="docutils literal notranslate"><span class="pre">initial_amplitude</span></code>. Fix seeds to obtain reproducible phase noise. Select
<code class="docutils literal notranslate"><span class="pre">time_points</span></code> suitably to resolve the spectrum in frequency domain. After
<code class="docutils literal notranslate"><span class="pre">corr_time</span></code> turns, the seed is changed (reproducibly) to cut numerical
correlated sequences of the random number generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>GeneralParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.general_parameters.GeneralParameters</span></code></p></li>
<li><p><strong>RFSectionParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.rf_parameters.RFSectionParameters</span></code></p></li>
<li><p><strong>time_points</strong> (<em>int</em>) – number of phase noise points of a sample in time
domain</p></li>
<li><p><strong>corr_time</strong> (<em>int</em>) – number of turns after which seed is changed</p></li>
<li><p><strong>fmin</strong> (<em>double</em>) – spectrum lower limit in units of synchrotron frequency</p></li>
<li><p><strong>fmax</strong> (<em>double</em>) – spectrum upper limit in units of synchrotron frequency</p></li>
<li><p><strong>initial_amplitude</strong> (<em>double</em>) – initial double sided spectral density
[<span class="math notranslate nohighlight">\(\text{rad}^2/\text{Hz}\)</span>]</p></li>
<li><p><strong>seed1</strong> (<em>int</em>) – seed for random number generator</p></li>
<li><p><strong>seed2</strong> (<em>int</em>) – seed for random number generator</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">time_points</span></code> should be chosen large enough to resolve the
desired frequency step <span class="math notranslate nohighlight">\(\Delta f =\)</span>
<code class="xref py py-attr docutils literal notranslate"><span class="pre">GeneralParameters.f_rev</span></code>/<code class="xref py py-attr docutils literal notranslate"><span class="pre">LHCFlatSpectrum.time_points</span></code>
in frequency domain.</p>
</div>
<dl class="method">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum.generate">
<code class="descname">generate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum.generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates LHC-type phase noise array (length:
<code class="xref py py-attr docutils literal notranslate"><span class="pre">GeneralParameters.n_turns</span></code> + 1). Stored in the variable
<code class="xref py py-attr docutils literal notranslate"><span class="pre">LHCFlatSpectrum.dphi</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="bunch-length-based-feedback-on-noise-amplitude">
<h3>Bunch-length based feedback on noise amplitude<a class="headerlink" href="#bunch-length-based-feedback-on-noise-amplitude" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.LHCNoiseFB">
<em class="property">class </em><code class="descclassname">llrf.rf_noise.</code><code class="descname">LHCNoiseFB</code><span class="sig-paren">(</span><em>object).__init__(bl_target</em>, <em>gain = 1.5</em>, <em>factor = 0.8</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.LHCNoiseFB" title="Permalink to this definition">¶</a></dt>
<dd><p>Feedback on phase noise amplitude for LHC controlled longitudinal emittance
blow-up using noise injection through cavity controller or phase loop.
The feedback compares the FWHM bunch length of the bunch to a target value
and scales the phase noise to keep the targeted value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bl_target</strong> – Targeted 4-sigma-equivalent FWHM bunch length [ns]</p></li>
<li><p><strong>gain</strong> – feedback gain [1/ns]</p></li>
<li><p><strong>factor</strong> – feedback recursion scaling factor [1]</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note that the FWMH bunch length is scaled by
<span class="math notranslate nohighlight">\(\sqrt{2/\ln{2}}\)</span> in order to obtain a 4-sigma equivalent value.</p>
</div>
<dl class="method">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.LHCNoiseFB.FB">
<code class="descname">FB</code><span class="sig-paren">(</span><em>RFSectionParameters</em>, <em>Beam</em>, <em>PhaseNoise</em>, <em>Slices</em>, <em>CC = False</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.LHCNoiseFB.FB" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the bunch-length based feedback scaling factor as a function
of measured FWHM bunch length. For phase noise injected through the
cavity RF voltage, the feedback scaling can be directly applied on the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">RFSectionParameters.phi_noise</span></code> variable by setting
<code class="docutils literal notranslate"><span class="pre">CC</span> <span class="pre">=</span> <span class="pre">True</span></code>. For phase noise injected through the <code class="xref py py-class docutils literal notranslate"><span class="pre">PhaseLoop</span></code>
class, the correction can be applied inside the phase loop, via passing
<code class="xref py py-class docutils literal notranslate"><span class="pre">LHCNoiseFB</span></code> as an argument in <code class="xref py py-class docutils literal notranslate"><span class="pre">PhaseLoop</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RFSectionParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.rf_parameters.RFSectionParameters</span></code></p></li>
<li><p><strong>Beam</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">beams.beams.Beam</span></code></p></li>
<li><p><strong>PhaseNoise</strong> – phase-noise type class,
<a class="reference internal" href="#blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise" title="blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise"><code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.rf_noise.PhaseNoise</span></code></a> or
<a class="reference internal" href="#blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum" title="blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.rf_noise.LHCFlatSpectrum</span></code></a></p></li>
<li><p><strong>Slices</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">beams.slices.Slices</span></code></p></li>
<li><p><strong>CC</strong> (<em>bool</em>) – cavity controller option</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="classmethod">
<dt id="blond.llrf.rf_modulation.fwhm">
<em class="property">classmethod </em><code class="descclassname">blond.llrf.rf_modulation.</code><code class="descname">fwhm</code><span class="sig-paren">(</span><em>Slices</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.fwhm" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast FWHM bunch length calculation with slice width precision.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Slices</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">beams.slices.Slices</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>4-sigma-equivalent FWHM bunch length [ns]</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-blond.llrf.signal_processing">
<span id="signal-processing-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal_processing</span></code> Module<a class="headerlink" href="#module-blond.llrf.signal_processing" title="Permalink to this headline">¶</a></h2>
<p><strong>Filters and methods for control loops</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p><strong>Helga Timko</strong></p>
</dd>
</dl>
<dl class="function">
<dt id="blond.llrf.signal_processing.cartesian_to_polar">
<code class="descclassname">blond.llrf.signal_processing.</code><code class="descname">cartesian_to_polar</code><span class="sig-paren">(</span><em>IQ_vector</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.cartesian_to_polar" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert data from Cartesian (I,Q) to polar coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>IQ_vector</strong> (<em>complex array</em>) – Signal with in-phase and quadrature (I,Q) components</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>float array</em> – Amplitude of signal</p></li>
<li><p><em>float array</em> – Phase of signal</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="blond.llrf.signal_processing.comb_filter">
<code class="descclassname">blond.llrf.signal_processing.</code><code class="descname">comb_filter</code><span class="sig-paren">(</span><em>y</em>, <em>x</em>, <em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.comb_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Feedback comb filter.</p>
</dd></dl>

<dl class="function">
<dt id="blond.llrf.signal_processing.low_pass_filter">
<code class="descclassname">blond.llrf.signal_processing.</code><code class="descname">low_pass_filter</code><span class="sig-paren">(</span><em>signal</em>, <em>cutoff_frequency=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.low_pass_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Low-pass filter based on Butterworth 5th order digital filter from
scipy,
<a class="reference external" href="http://docs.scipy.org">http://docs.scipy.org</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>float array</em>) – Signal to be filtered</p></li>
<li><p><strong>cutoff_frequency</strong> (<em>float</em>) – Cutoff frequency [1] corresponding to a 3 dB gain drop, relative to the
Nyquist frequency of 1; default is 0.5</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Low-pass filtered signal</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="blond.llrf.signal_processing.modulator">
<code class="descclassname">blond.llrf.signal_processing.</code><code class="descname">modulator</code><span class="sig-paren">(</span><em>signal</em>, <em>omega_i</em>, <em>omega_f</em>, <em>T_sampling</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.modulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Demodulate a signal from initial frequency to final frequency. The two
frequencies should be close.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>float array</em>) – Signal to be demodulated</p></li>
<li><p><strong>omega_i</strong> (<em>float</em>) – Initial revolution frequency [1/s] of signal (before demodulation)</p></li>
<li><p><strong>omega_f</strong> (<em>float</em>) – Final revolution frequency [1/s] of signal (after demodulation)</p></li>
<li><p><strong>T_sampling</strong> (<em>float</em>) – Sampling period (temporal bin size) [s] of the signal</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Demodulated signal at f_final</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="blond.llrf.signal_processing.moving_average">
<code class="descclassname">blond.llrf.signal_processing.</code><code class="descname">moving_average</code><span class="sig-paren">(</span><em>x</em>, <em>N</em>, <em>x_prev=None</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.moving_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to calculate the moving average (or running mean) of the input
data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>float array</em>) – Data to be smoothed</p></li>
<li><p><strong>N</strong> (<em>int</em>) – Window size in points</p></li>
<li><p><strong>x_prev</strong> (<em>float array</em>) – Data to pad with in front</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>Smoothed data array of size</dt><dd><ul class="simple">
<li><p>len(x) - N + 1, if x_prev = None</p></li>
<li><p>len(x) + len(x_prev) - N + 1, if x_prev given</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="blond.llrf.signal_processing.polar_to_cartesian">
<code class="descclassname">blond.llrf.signal_processing.</code><code class="descname">polar_to_cartesian</code><span class="sig-paren">(</span><em>amplitude</em>, <em>phase</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.polar_to_cartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert data from polar to cartesian (I,Q) coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>amplitude</strong> (<em>float array</em>) – Amplitude of signal</p></li>
<li><p><strong>phase</strong> (<em>float array</em>) – Phase of signal</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Signal with in-phase and quadrature (I,Q) components</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="blond.llrf.signal_processing.rf_beam_current">
<code class="descclassname">blond.llrf.signal_processing.</code><code class="descname">rf_beam_current</code><span class="sig-paren">(</span><em>Profile</em>, <em>omega_c</em>, <em>T_rev</em>, <em>lpf=True</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.rf_beam_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Function calculating the beam charge at the (RF) frequency, slice by
slice. The charge distribution [C] of the beam is determined from the beam
profile <span class="math notranslate nohighlight">\(\lambda_i\)</span>, the particle charge <span class="math notranslate nohighlight">\(q_p\)</span> and the real vs.
macro-particle ratio <span class="math notranslate nohighlight">\(N_{\mathsf{real}}/N_{\mathsf{macro}}\)</span></p>
<div class="math notranslate nohighlight">
\[Q_i = \frac{N_{\mathsf{real}}}{N_{\mathsf{macro}}} q_p \lambda_i\]</div>
<p>The total charge [C] in the beam is then</p>
<div class="math notranslate nohighlight">
\[Q_{\mathsf{tot}} = \sum_i{Q_i}\]</div>
<p>The DC beam current [A] is the total number of charges per turn <span class="math notranslate nohighlight">\(T_0\)</span></p>
<div class="math notranslate nohighlight">
\[I_{\mathsf{DC}} = \frac{Q_{\mathsf{tot}}}{T_0}\]</div>
<p>The RF beam charge distribution [C] at a revolution frequency
<span class="math notranslate nohighlight">\(\omega_c\)</span> is the complex quantity</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left( \begin{matrix} I_{rf,i} \\
Q_{rf,i} \end{matrix} \right)
= 2 Q_i \left( \begin{matrix} \cos(\omega_c t_i) \\
\sin(\omega_c t_i)\end{matrix} \right) \, ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(t_i\)</span> are the time coordinates of the beam profile. After de-
modulation, a low-pass filter at 20 MHz is applied.</p>
<p>For multi-bunch cases, make sure that the real beam intensity is the total
number of charges in the ring.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Profile</strong> (<em>class</em>) – A Profile type class</p></li>
<li><p><strong>omega_c</strong> (<em>float</em>) – Revolution frequency [1/s] at which the current should be calculated</p></li>
<li><p><strong>T_rev</strong> (<em>float</em>) – Revolution period [s] of the machine</p></li>
<li><p><strong>lpf</strong> (<em>bool</em>) – Apply low-pass filter; default is True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>RF beam charge array [C] at ‘frequency’ omega_c. To obtain current,
divide by the sampling time</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="monitors.html" class="btn btn-neutral float-right" title="monitors Package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="input_parameters.html" class="btn btn-neutral" title="input_parameters Package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
   

</body>
</html>